1. Корректность использования scalars

query_select = await session.execute(select(getattr(orm_clss, key_column), getattr(orm_clss, value_column)))
return {getattr(row, value_column): getattr(row, key_column) for row in query_select.scalars().all()}

Здесь вы используете scalars().all(), однако select возвращает не один столбец, а два (key_column и value_column). Использование scalars приведет к тому, что будет извлечен только один из столбцов, а в словаре получится ошибка. Нужно убрать scalars и использовать:

return {row[value_column]: row[key_column] for row in query_select.all()}

2. Эффективное обновление данных

Ваш цикл обновления использует несколько вызовов execute:

for lot in lots_to_update:
    await session.execute(
        update(models.MainDataORM)
        .where(models.MainDataORM.lot_number == lot["lot_number"])
        .values(
            buy_it_now_price=lot["buy_it_now_price"],
            buy_it_now_flag=lot["buy_it_now_flag"],
            current_bid=lot["current_bid"],
        )
    )

Это неэффективно, так как каждая операция обновления отправляется в базу данных отдельно. Вы можете использовать session.bulk_update_mappings, чтобы обновить данные пачкой:

await session.bulk_update_mappings(models.MainDataORM, lots_to_update)

3. Закрытие сессии

В async with контексте:

async with async_session_factory() as session:
    ...
    await session.close()

Явный вызов await session.close() не требуется, так как он автоматически выполняется при выходе из контекста async with.
4. Ошибки при асинхронных функциях

Следует быть внимательным с обработкой исключений в асинхронном контексте. Добавление отлова ошибок поможет избежать неожиданного завершения программы:

try:
    # main logic here
except Exception as e:
    await session.rollback()
    raise e
finally:
    await session.close()

5. Утилизация кэша

related_data и cache_dict сохраняются только в текущем сеансе. Если объем данных большой, а update_data вызывается часто, подумайте о более долгосрочном кэше (например, Redis или in-memory store).
Финальная версия с учетом предложений:

    Убрать лишние close.
    Использовать bulk_update_mappings.
    Улучшить обработку исключений.

Эти изменения улучшат производительность и обеспечат надежность при обновлении данных.


